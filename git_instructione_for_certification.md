![Тут должен быть логотип](Softwaredeployment-met-Git-en-SVN-via-SSH.jpg)
# Работа с Git
## Проверка наличия установленного git
В терминале выполняем команду git version. Если git установлен, появится сообщение с информацией о версии файла.Вот так:

![Версия git](версия_гита.png)

Иначе, будет сообщение об ошибке.
## Настройка git
При первом использовании git необходимо представиться. Для этого надо ввести 2 команды:
* git config --clobal user.email
* git congig --clobal user.name
Для того, чтобы проверить прошла ли регистрация надо ввести команду git config --list
## Идентификация репозитория
Для того, чтобы получить репозиторий из папки, выполняем команду git init. В исходной папке появится скрытая папка .git.
## Проверка репозитория
Чтобы отобразить состояние репозитория и проиндексированные файлы, вводим команду git status. Она покажет зафиксированные файлы и те, которые git еще не отслеживает (цельком или частичные изменения в них). Модифицированное, но не сохраненное пишется красным, как на скрине ниже:

![Есть 1 модифицированный и несохраненный файл](статус_с_модифицированным_несохраненным.png)

То есть, команда git status демонстрирует изменения, внесенные с помощью команд git add и git commit + инструкцию по индексированию файлов либо отмене этой операции.
Если команда не видит с чем работать и все зафиксировано, будет так:

![Со статусом все ок](статус.png)

## Индексация изменений
Выполняется командой git add. Это первая команда в цепочке операций, предписывающих git сохранить текущее состояние проекта в истории коммитов. Git add индексирует сразу все и змененные файлы и папки в директории.
## Сохранение проиндексированных изменений
Выполняется командой git commit. При первичном сохранении в рамках одного файла ей обязательно предшествует команда git add. При последующих сохранениях в рам ках этого же файла, можно использовать команду git commit -am.
К любому коммиту обязательно прилагается текстовый комментарий, отражающий суть сохраняемых изменений.
У команды git commit есть 3 возможных аргумента:
* -m (позволяет написать текстовое сообщение без открытия редактора)
* -а (позволяет пропустить комманду git add, перенося все отслеживаемые файлы в область подготовленных файлов)
* --amend (заменяет последний коммит новым измененным коммитом)
## Просмотр истории коммитов
Производится с помощью команды git log. История выводится в формате: верхний коммит - самый новый, а нижний - самый первый.
У команды есть следующие возможные параметры:
* git log --oneline (выдает историю коммитов с коротким хэшем)
* git log --stat (список коммитов + статистика по каждому)
* git log --pretty=oneline (выводит список коммитов по одному на строке)
* git log --graph (показывает древовидную структуру истории)
* git log --since="today" (показывает коммиты за сегодня)
* git log --name-only (показывает список измененных файлов)
* git log -p (показывает diff каждого коммита)
* git log -5 (просмотр последних пяти коммитов)
Краткий список коммитов для примера:

![Вывод краткого списка коммитов](краткие_коммиты.png)
## Анализ разницы между текущим и сохраненным состоянием
Производится командой git diff. Она выводит разницу на экран в виде измененных строк: какие добавлены (знак +) и какие удалены (знак -). Иногда, могут выводиться и блиджайшие к ним строки для простоты ориентации.
Есть возможность перемещаться по выводу, ища внутри него нужные данные. Для этого используем клавиши:
* f - перемещение вниз
* b или u - вверх
* q -выход из режима просмотра
По умолчанию diff показывает изменения лишь в тех файлах, которые еще не проиндексированны.
## Переключение версий сохранения
Производится командой git checkout. С ее помощью можно работать с файлами, фиксациями (коммитами) и ветвями. К примеру, для просмотра конкретного коммита вводим git checkout + идентиикационный номер коммита (достаточно первых 4-6 симвов и нажать tab). 
Работа с ветвями разобрана в разделе "Ветвление".
## Добавление картинок и игнорирование файлов
Чтобы разместить картинку в файле, надо добавить ее в папку и вставить в нужное место файла командой ![текст на случай НЕ загрузки картинки](имя картинки вместе с расширением). После этого картинка отобразится в проводнике. Вот так:

![Быть мне разработчиком](1681094210_sneg-top-p-programmist-kartinki-instagram-17.jpg)

Чтобы не добавлять картинку и прочие тяжелые, нетекстовые единицы в отслеживание, в папке создается файл .gitignore.
В файл .gitignore можно:
* вносить имена каждой из убираемой из отслеживания картинки
* либо (что удобнее) вписать расширение картинок в таком формате: *.jpg (или другое расширение). Вот так:

![Расширения в файле .gitignore](расширения_в_гитигнор.png)
## Ветвление
Ветвление позволяет вносить изменения в файл в отдельной ветке,сохраняя при этом исходное состояние файла до их слияния.
Для создания новой ветки вводим в терминале команду git brench + имя ветки.
Для отображения всех имеющизся веток с пометкой звездочкой (*) и зеленым цветом той, на которой сейчас находимся, используется команда git branch. Список созданных и имеющихся веток видно на скрине ниже:

![У нас есть 4 ветки](создала_4_ветки_удалила_1.png)

Для перехода на другую ветку вводим команду git cgeckout + имя ветки. Вот так:

![Скачу по веткам](скачу_по_веткам.png)

Для переноса инфы из одной ветки в другую, переходим в ту, куда надо стянуть инфу и там вводим команду git merge + имя ветки, с которой добавляем инфу. К примеру, если я в master и мне надо добавить туда написанное в ветке 1, ввожу git merge 1. Вот так:

![Слияние веток](вливание_ветки1_в_мастер.png)

Для удаления уже не нужной ветки добавляем к команде git branch + имя ветки флаг -d (от delit  удалить), вот так: git branch -d Kira. Вот так:

1. Пример1
![Удаление ветки](удаление_ветки.png)
![Вот что должна в итоге показать команда git branch](удаление_ветки_проверка.png)

2. Пример2
![Уще одно удаление ветки](удалила_ветку_conflict.png)

## Конфликты
Конфликты возникают при слиянии 2 веток в одну, когда в этих ветках была изменена одна и таже строка(и)файла.
Разрешение конфликта возможно путем сдедующих методов:
* принять текущие изменения (первая надпись над зеленой частью конфликта)
* принять входящие изменения (вторая надпись над зеленой частю конфликта)
* принять оба изменения (третья по счету надпись тамже)
* сравнить изменения (иначе, править вручную, это последняя надпись тамже)
Выглядит это так:

1. Конфликт1
 ![Конфликт](конфликт.png)

2. Конфликт2
 ![Конфликт2](конфликт2.png)

 Разрешение конфликта путем принятия текущих изменений:
 
 ![Разрешение конфликта путем принятия текущих изменений](конфликт_разрешен_принятием_текущей_версии.png)
## Работа с удаленными репозиториями
Необходима при направлении своих данных в интернет, или стягивании чьих-то данных к себе на локальный (чисто на своем компе) носитель.
Работа с удалеными репозиториями ведется по средствам сервиса Githab и подобных ему (создающих единую экосистему с Гитом).
### Копирование удаленных репозиториев
Выполняется нажатием кнопки fork на Github.

Fork является копированием нужного чужого репозитория к себе в профиль на Githab.

Из своего профиля форкнутый репозиторий можно клонировать локально к себе на комп.
### Клонирование удаленного репозитория
Выполняется командой git clone + ссылка на нужный репозиторий в Github.
Ссылка копируется на кнопке Code.
Команда совершается в VSCode после форка (fork) в Githab. 

Команда git clone в VSCode пересылает копию репозитория из интернета (Github) ко мне на комп, где работаю с ней локально.

! Клонирование выполняется в папку НЕ репозиторий, чтобы избежать помещения одного репозитория в другой и конфликтов между ними.
### Передача локальных данных в удаленный репозиторий
Выполняется командой git push после доработ ок в клонированном репозитории.

! Доработки выполняются в отдельной ветке, дабы не пушить в ветку master и не носить такую кликуху до увольнения.

Поскольку новая ветка создается локально и еще не существует в удаленном репозитории, вводится команда, подсказываемая VSCode в терминале после ввода команды git push. После этой команды новая ветка отсылается в удаленный репозиторий, где его хозяину предлагается смержить.
### Стягивание данных с удаленного репозитория к себе для локальной работы
Выполняется комадой git pull.

Эта команда стягивает изменения в удаленном репозитории в локальный. Команда составная, передает инфу сразу со всех веток, мержа их.
### Запрос принятия сделанных в локальном репозитории изменений хозяином удаленного
Выполняется нажатием кнопки Pull request на Github.

Эта кнопка высвечивается после правильного пуша на Github и дает запрос хозяину репозитория на интеграцию изменений из одной ветки (созданной мной) в другую (хозяйскую).