
# Работа с git

## Проверка наличия установленного Git 

В терминале выполняем команду git version - данная команда выводит версию программы git. Если выдает ошибку - git не установлен.

## Установка Git

Загружаем последнюю версию с сайта https://git-scm.com/download/win, устанавливаем с настройками по умолчанию (симулятор нажатия кнопки next)

## Настройка Git

1. git config --global user.name "username"
2. git config --global user.email "useremail"

Чтобы проверить, запомнил ли Git наши данные, можно ввести команду git config --list

## Инциализация Git

Чтобы инициализировать Git, открыть папку с проектом через VScode, ввести команду git init.

## Клонирование репозитория

клонировать удаленный репозиторий в одноименную директорию
git clone https://github.com/cyberspacedk/Git-commands.git

клонировать удаленный репозиторий в директорию «FolderName»
git clone https://github.com/cyberspacedk/Git-commands.git FolderName

клонировать репозиторий в текущую директорию
git clone https://github.com:nicothin/web-design.git

## Git статус

Чтобы получить информацию  от git о его текущем состоянии, ввести команду git status.

## Просмотр изменений

git status              # показать состояние репозитория (отслеживаемые, изменённые, новые файлы и пр.)

git diff                # сравнить рабочую директорию и индекс (неотслеживаемые файлы ИГНОРИРУЮТСЯ)

git diff --color-words  # сравнить рабочую директорию и индекс, показать отличия в словах (неотслеживаемые файлы ИГНОРИРУЮТСЯ)

git diff index.html     # сравнить файл из рабочей директории и индекс

git diff HEAD           # сравнить рабочую директорию и коммит, на который указывает HEAD (неотслеживаемые файлы ИГНОРИРУЮТСЯ)

git diff --staged       # сравнить индекс и коммит с HEAD

git diff master feature # посмотреть что сделано в ветке feature по сравнению с веткой master

git diff --name-only master feature # посмотреть что сделано в ветке feature по сравнению с веткой master, показать только имена файлов

git diff master...feature # посмотреть что сделано в ветке feature с момента (коммита) расхождения с master

## Добавление файла к следующему commit Git

Чтобы добавить файл или файлы к следующему коммиту, ввести команду git add.

## Создание коммита

Чтобы создать коммит git, ввести команду git commit -m "message".

## Удаление изменений из индекса

git reset           # убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся), 

## Отмена изменений

it checkout text.txt      # ОПАСНО: отменить изменения в файле, вернуть состояние файла, имеющееся в индексе

git reset --hard           # ОПАСНО: отменить изменения; вернуть то, что в коммите, на который указывает HEAD 
(незакомиченные изменения удалены из индекса и из рабочей директории, неотслеживаемые файлы останутся на месте)

git clean -df              # удалить неотслеживаемые файлы и директории

## Отмена коммитов и перемещение по истории

Все коммиты, которые уже были отправлены в удалённый репозиторий, должны отменяться новыми коммитами (git revert), дабы избежать проблем с историей разработки у других участников проекта.

git revert HEAD --no-edit    # создать новый коммит, отменяющий изменения последнего коммита без запуска редактора сообщения

git revert b9533bb --no-edit # то же, но отменяются изменения, внесённые коммитом с указанным хешем (b9533bb)

Все команды, приведённые ниже можно выполнять ТОЛЬКО если коммиты еще не были отправлены в удалённый репозиторий.

# ВНИМАНИЕ! Опасные команды, можно потерять незакоммиченные изменения
git commit --amend -m "Название"  # «перекоммитить» изменения последнего коммита, заменить его новым коммитом с другим сообщением (сдвинуть текущую ветку на один коммит назад, сохранив рабочую директорию и индекс «как есть», создать новый коммит с данными из «отменяемого» коммита, но новым сообщением)

git reset --hard @~      # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию и индекс сделать такими, какими они были в момент предыдущего коммита

git reset --hard 75e2d51 # передвинуть HEAD (и ветку) на коммит с указанным хешем, рабочую директорию и индекс сделать такими, какими они были в момент указанного коммита

git reset --soft @~      # передвинуть HEAD (и ветку) на предыдущий коммит, но в рабочей директории и индексе оставить все изменения

git reset --soft @~2     # то же, но передвинуть HEAD (и ветку) на 2 коммита назад

git reset @~             # передвинуть HEAD (и ветку) на предыдущий коммит, рабочую директорию оставить как есть, индекс сделать таким, каким он был в момент предыдущего коммита (удобнее, чем git reset --soft @~, если индекс нужно задать заново)

# Почти как git reset --hard, но безопаснее: не получится потерять изменения в рабочей директории

git reset --keep @~      # передвинуть HEAD (и ветку) на предыдущий коммит, сбросить индекс, но в рабочей директории оставить изменения, если возможно (если файл с изменениями между коммитами менялся, будет выдана ошибка и переключение не произойдёт)

## Git log

Чтобы вывести на экран истории всемх коммитов с их хеш-кодами, ввести команду git log.

## Git checkout

Чтобы перейти от одного коммита к другому, ввести команду git checkout.

## Checkout master

Чтобы вернуться к актуальному состоянию и продолжить работу, ввести команду git checkout master.

## Git diff

Чтобы увидеть разницу между текущим файлом и закоммиченным файлом, ввести команду git diff.
## Добавление картинок и игнорирование файлов

Чтобы добавить картинку, нужно ввести команду "! [] ()"

Чтобы добавить игнорируемый файл, необходимо создать файл ".gitignore", в появившейся строке пишем "имя файла. расширение файла". Затем вводим команду - git add.
Чтобы сделать игнорируемыми все изображения, нужно в появившемся окне .gitignore прописать - *.png(формат файла).

Conflict situation
![](conflict.png)

## Ветки

![Logo](Logo.jpeg)

git branch                 # показать список веток

git branch -v              # показать список веток и последний коммит в каждой

git branch new_branch      # создать новую ветку с указанным именем на текущем коммите

git branch new_branch 5589877 # создать новую ветку с указанным именем на указанном коммите

git branch -f master 5589877  # переместить ветку master на указанный коммит

git branch -f master master~2 # переместить ветку master на 2 коммита назад

git checkout new_branch    # перейти в указанную ветку

git checkout -b new_branch # создать новую ветку с указанным именем и перейти в неё

git checkout -B master 5589877 # переместить ветку с указанным именем на указанный коммит и перейти в неё

git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix

git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)

git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов

git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния

git branch -d hotfix       # удалить ветку hotfix (используется, если её изменения уже влиты в главную ветку)

git branch --merged        # показать ветки, уже слитые с активной

git branch --no-merged     # показать ветки, не слитые с активной

git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)

git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name

git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name

git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории

git branch --unset-upstream # завершить процесс переименования

## "Перенос" ветки

Можно «переместить» ответвление какой-либо ветки от основной на произвольный коммит. Это нужно для того, чтобы в «переносимой» ветке появились какие-либо изменения, внесённые в основной ветке (уже после ответвления переносимой).

Нельзя «переносить» ветку, если она уже отправлена на удалённый репозиторий.

git rebase master # перенести все коммиты (создать их копии) активной ветки так, будто активная ветка ответвилась от master на нынешней вершине master (часто вызывает конфликты)

git rebase --onto master feature # перенести коммиты активной ветки на master, начиная с того места, в котором активная ветка отделилась от ветки feature

git rebase --abort # прервать конфликтный rebase, вернуть рабочую директорию и индекс к состоянию до начала rebase

git rebase --continue # продолжить конфликтный rebase (сработает только после разрешения конфликта и индексации такого разрешения)

## Как отменить rebase

git reflog feature -2        # смотрим лог перемещений ветки, которой делали rebase (в этом примере — feature), видим последний коммит ПЕРЕД rebase, на него и нужно перенести указатель ветки

git reset --hard feature@{1} # переместить указатель ветки feature на один коммит назад, обновить рабочую директорию и индекс
