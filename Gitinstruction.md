![pic_logo](logo_git.png)
# Инструкция по установке и работе в программе GIT
## Установка и настройка программы GIT

Программа GIT - это система контроля версий, которая работает с локальными и удаленными репозиториями, необходима для отслеживания изменений в файлах, хранит информацию о ветках.

На сайте git-scm.com скачать программу Git, выбрав в загрузках свою операционную систему с учетом разрядности.

Далее на сайте *code.visualstudio.com* скачать дополнительную программу VSCode, выбрав в загрузках свою операционную систему. 

После установки программы Git в VSCode необходимо указать имя пользователя и email при помощи двух команд:

* *git config --global user.name "Имя"* - в кавычках указать свое имя

* *git config --global user.email Адрес@email.com* - указать адрес эл.почты, который далее будет зарегистрирован в удаленном репозитории

---
![pic_00](00_настр_Git.jpg)

---

Произвести другие настройки, необходимые для работы в программе.

Командой *git --version* можно проверить, как настроен Git. Если после ее введения появляется надпись типа *git version 2.40.0.windows.1*, значит программа настроена правильно.

---
![pic_00_01](00_01_version.jpg)

---

## Инициализация репозитория

Репозиторий служит для отслеживания изменений файлов создаваемого проекта.

Для его создания необходимо через проводник в VSCode зайти в папку, которая в дальнейшем будет служить репозиторием, открыть терминал и ввести в нем команду *git init*.

В этот же момент Git начнет отслеживать содержимое папки.

В папке появится скрытая папка *.git*

Проверить, что произошло при создании репозитория, можно командой *git status*. Git покажет, что мы находимся в ветке *master (main)*, пока нет никаких commits (фиксаций) и рекомендации, что можно сделать далее.

***Важно!*** 

В репозитории нельзя создавать другой репозиторий. Нужно быть очень внимательным при введении команды *git init*, не вводить ее более одного раза. Желательно перед командой инициирования репозитория проверить, не является ли эта папка уже репозиторием (командой *git status*). 

Чтобы из репозитория сделать снова обычную папку, необходимо обнаружить скрытую папку *.git*, двигаясь в иерархии папок с нижнего уровня к верхнему, и удалить ее. 

## Запись изменений в репозиторий

1. Команда *git add file_name*.

Чтобы добавить файл для отслеживания изменений в репозитории, необходимо после его создания (с обязательным указанием расширения) ввести команду *git add file_name*, причем название файла можно ввести несколькими первыми символами + Tabe (произойдет автозаполнение).
В проводнике напротив файла появится буква “A”.

Если в файле произведены какие-либо изменения, нужно также добавить их к отслеживанию командой *git add file_name*, предварительно сохранив их в файле (Ctrl+S)

---
![pic_03](03_git_add_commit.jpg)

---

2. Команда *git commit -m “Комментарий”*.

Зафиксировать изменения в файле можно командой *git commit -m “Комментарий”*. Git опишет произошедшие изменения, например, 1 файл изменен, в него добавлена 1 строка, удалено 2 строки, добавлен 1 комментарий.

---
![pic_03](03_git_add_commit.jpg)

---

***Важно!*** 

Команду *git commit -m “Комментарий”* необходимо осуществить сразу после команды *git add file_name* - обязательное условие для корректного сохранения коммита.

Комментарий обязателен. 

Комментарий пишется на английском языке.

Есть возможность исправить комментарий только к последнему коммиту командой *git commit --amend -m ”Правильный комментарий”*.

---
![pic_03_dop](git_commit_amend.jpg)

---

3. Команда *git status*.

Показывает актуальное состояние файла.

Например, после создания файла, при введении команды *git status* Git покажет, что появился файл (подсвечен красным), но он его пока не отслеживает.

После введения команды *git add file_name*, при введении команды *git status* Git покажет, что файл (подсвечен зеленым) принят к отслеживанию, в нем появились некоторые изменения, которые могут быть зафиксированы.

---
![pic_03_01](03_01_02_status.jpg)

---

4. Переименование файла в репозитории.

При переименовании файла, при введении команды *git status* Git покажет, что есть *deleted file* (подсвечен красным), и есть *untracked file* (подсвечен красным).

Для принятия переименованного файла к отслеживанию, следует произвести команду *git add new_file_name*, затем  *git commit -m “Комментарий о переименовании”*.

При этом в проводнике будет один переименованный файл.
Но, при возвращении к предыдущим версиям проекта, появится и файл с предыдущим названием (в проводнике будут отображаться оба варианта файла)

***Важно!*** 

Между командами в программе Git можно перемещаться при помощи ↓↑

## Получение информации об истории коммитов

1. Команда *git log* выводит журнал изменений. 

Желтым цветом выделены названия коммитов, также указан комментарий к каждому коммиту. 

История коммитов выводится снизу вверх (т.е. последний коммит будет в самых верхних строчках журнала).

---
![pic_08_05](08_05_git_log.jpg)

---

2. Команда *git log --oneline* выводит журнал изменений в более компактном виде, чем команда *git log*.

---
![pic_08_04](08_04_git_log_oneline.jpg)

---

3. Команда *git log --graph* визуализирует все изменения дерева коммитов в несколько ином виде, нежели команда *git log*.

---
![pic_08_03](08_03_git_log_graph.jpg)

---

***Важно!*** 

Для выхода из многострочного вывода данных нажать “q” (quit)  

## Сравнение с последним коммитом

Команда *git diff* показывает разницу между текущим и предыдущим (сохраненным) состоянием файла.

Если после работы в файле изменения не были сохранены, то команда *git diff* покажет, что состояние файла идентично предыдущей версии.

Если изменения в файле были зафиксированы, то она покажет какие изменения произошли. Например, удаленные строки или файлы (подсвечены красным и отмечены знаком “-”), добавленные строки или файлы  (подсвечены зеленым и отмечены знаком “+”)

---
![pic_05](05_git_diff.jpg)

---

## Перемещение между сохранениями

Команда *git checkout* позволяет перемещаться между сохранениями и ветками репозитория. 

Для перемещения к одному из предыдущих коммитов при вводе команды *git checkout* через пробел добавляются 4 первые символа необходимого коммита.

Для перехода к другой ветке репозитория вводится команда *git checkout branch_name*.

Проверить произошел ли переход с одного коммита на другой (или с одной ветки на другую) можно командой *git branch* (коммит или ветка будет подсвечена зеленым и отмечена “*”) или командой *git status*.

***Важно!*** При переходе от одного коммита к другому необходимо перейти не только в нужный коммит, но и второй командой *git checkout branch_name* перейти на соответствующую ветку (например, “git checkout master”).

---
![pic_06](06_git_checkout.jpg)

---

## Работа с изображениями

1. Чтобы добавить изображение в файл, с которым мы работаем, необходимо выбранную картинку добавить в папку с репозиторием.

В тексте нашего файла, где будет расположена картинка, сделать запись: 

*![имя картинки](file_name)*. 

Картинка автоматически подтянется. 

***Важно!*** 

При именовании картинки писать имя следует или *Snake_case* или *CamelСase*.

2. Файл *.gitignore*

Чтобы не перегружать git работой (не отслеживать некоторые файлы), их добавляют в файл *.gitignore*.

В файл *.gitignore* можно добавить как все имена файлов (обязательно с расширением), так и название расширений (например, *.jpg*), которые будут исключены для отслеживания.

Сам файл *.gitignore* необходимо внести в список отслеживаемых командами:  
*git add .gitignore* и *git commit -m “Комментарий”*.

При этом файлы, прописанные в файле *.gitignore* в список отслеживаемых не вносить! Файлы, внесенные в список *.gitignore* будут окрашены серым цветом.

---
![pic_07_01](07_01_изобр.jpg)

---

---
![pic_07_02](07_02_изобр.jpg)

---

---
![pic_07_03](07_03_изобр.jpg)

---

## Работа с ветками репозитория

Ветка - это набор commit, которые идут друг за другом. 

Основную ветку чаще всего называют *master* или *main* ( это наш проект).

Обычно в основной ветке (*master* или *main*) только сливают изменения из других веток.

Другие ветки создают как отдельное место, где реализуют новый функционал, исправляют ошибки и т.д.

1. Команда *git branch new_branch_name*
Служит для создания новой ветки.
---
![pic_09](09_git_branch_b_name.jpg)

---

***Важно!*** 

При именовании ветки писать имя следует или *Snake_case* или *Camel_case*.

Перед созданием новой ветки нужно убедится, находимся ли мы в основной ветке (*master* или *main*) командами *git status* или *git branch*.

2. Команда *git branch*

Служит для вывода списка веток проекта. Активная ветка (в которой находимся) подсвечена зеленым и отмечена "*".

---
![pic_09_01](09_01_git_branch_B.jpg)

---
3. Команда *git checkout branch_name*

Служит для перехода от одной ветки к другой.

Проверить произошел ли переход с одной ветки на другую можно командой *git branch* (ветка будет подсвечена зеленым и отмечена “*”) или командой *git status*.

---
![pic_09_01_02](09_01_B_checkout.jpg)

---

***Важно!*** 

При переходе от одного коммита к другому необходимо перейти не только в нужный коммит, но и второй командой *git checkout branch_name* перейти на соответствующую ветку (например, *git checkout master*)

4. Команда *git checkout -b branch_name*

Позволяет создать ветку и сразу же переключится на нее.

5. Команда *git merge branch_name*

Позволяет слить ветку в *master* после завершения работы над задачей. 

Вызывать эту команду необходимо из той ветки, которая является основной, а *branch_name* в команде та, которую вливают.

---
![pic_09_02](09_02_git_merg_B.jpg)

---

6. При осуществлении команды *git merge branch_name* может возникнуть ситуация *CONFLICT*

Это происходит, если сливаемые ветки содержат разные изменения в одной и той же строчке коммита.

---
![pic_08_01](08_01_Conflict.jpg)

---

---
![pic_08](08_Сonflict.jpg)

---

Git предложит варианты для разрешения конфликта:

* *Accept Current Change* (принять текущее изменение)
* *Accept Incoming Change* (принять входящее изменение)
* *Accept Both Changes* (принять оба изменения)
* *Compare Changes* (сравнить изменения)

После принятия одного из вариантов, внести при необходимости соответствующие изменения и закоммитить.

---
![pic_08_02](08_02_Conflict_Resolution.jpg)

---

7. Команда *git branch -d branch_name*

После проведения команды *git merge branch_name* можно удалить не нужные ветки

## Работа в удаленном репозитории GitHub

Для работы в удаленном ремпозитории GitHab нужно создать на сайте https://github.com/ аккаунт и связать его со своей учетной записью.

На GitHub можно работать в репозитории на своем аккаунте, обмениваться данными со своим локальным репозиторием или репозиториями коллег, участвовать в работе над *open sourse project*.

1. Для создания репозитория на GitHub c локального, нужно в своем аккаунте на GitHub нажать на кнопку "+" и в выпадающем окне выбрать последующее действие (*new repositori* - создать новый репозиторий). 

В нем выбрать пункт, например, *привязать репозиторий к удаленному репозиторию* (если нужно отправить свой локальный репозиторий на GitHab)

GitHub выдаст подсказки, которые необходимо сделать в терминале VSCode:

*git remote add origin ссылка*
*git branch main(master)* - вписать свой вариант
*git push -u origin main(master)*

При первом *push* из VSCode необходимо будет пройти авторизацию. Репозиторий появится на GitHub.

---
![pic_10_01](10_01_GH_new_rep.jpg)

---

2. Для копирования репозитория с GitHub на свой локальный, нужно нажать кнопку *Code* на странице этого репозитоия и скопировать *ссылку на репозиторий*.

В локальном терминале VSCode создать новую папку,ввести в терминале команду *git clone ссылка_репозиторий*. Внутри папки появится папка скопированного репозитория.

***Важно!***

Для дальнейших изменений неоходимо перейти в папку скопированного репозитория командой *cd folder_name*, создать новую ветку (*git branch  branch_name*), перейти на нее *git checkout branch_name* и работать в новой ветке.

---
![pic_10_02](10_02_GH_clone.jpg)

---

3. Обмен данными между удаленным или локальным репозиториями.

Для передачи внесенных изменений в файле локального репозитория на GitHub служит команда *git push*. При переходе на GitHub следует обновить страницу, чтобы увидеть изменения в файле. Команда *git push* составная, она не только передает изменения, но и сделает merge веток, если возникнет конфликт, его нужно разрешить.

Для передачи внесенных изменений в файле с GitHub на локальный репозиторий служит команда *git pull*.

4. Участие в работе над открытыми проектами *open source project*

Проекты *open source project* предполагают участие в работе над ними других пользователей. Решение о внесении предложенных изменений принимает создатель открытого проекта.

- На странице *open source project* нажать кнопку *Fork*.

- После этого на своем аккаунте появится копия этого репозитория.

- Скопировать через кнопку *Code* ссылку этого репозитория (нажав предварительно *sync fork* для подтягивания возможно произошедших изменений)

---
![pic_10_03](10_03_GH_code.jpg)

---

- Далее следовать описанию п.2 раздела "Работа в удаленном репозитории GitHub"

***Важно!***

Для дальнейших изменений неоходимо перейти в папку скопированного репозитория командой *cd folder_name*, создать новую ветку (*git branch  branch_name*), перейти на нее *git checkout branch_name* и работать в новой ветке.

- По окончании работы над проектом его нужно отправить на свой аккаунт на GitHub командой git push --set-upstream origin branch_name (название той ветки, в которой вносились изменения).

---
![pic_10_04](10_04_GH_git_push.jpg)

---

- На GitHub после обноления страницы нужно нажать кнопку *Compare & pull request*

---
![pic_10_05](10_05_GH_compare.jpg)

---

Если все корректно, GitHube выдаст команду *Able to merge*.

Можно добавить описание запроса и нажать кнопку *Create pull request*.

---
![pic_10_06](10_06_GH_Create_pull_request.jpg)

---

В аккаунте *open source project* появится новое поле, в котором будет работать держатель проекта.
