![git logo](git_logo.jpeg)
# Работа с Git

## Проверка наличия установленного Git

В терминале выполняем команду git version - она вывовыдит версию программы git, если выдает ошибку, значит git не установлен 

## Установка Git

Загружаем последнию версиюю git с сайта https://git-scm.com/, устанавливаем с настройками по умолчанию (симулятор нажатия кнопки next)

## Настройка Git

1. git config --global user.name "username"
2. git config --global user.email "useremail"

Чтобы проверить запомнил ли Git наши данные, можно ввести команду git config --list

## Иницилизация Git

> git init

Чтобы иницилизировать git, нужно в папке с проектом ввести команду git init

## Добавление содержимого для последующего коммита

> git add "file name"

Команда git add "file name" (с расширением) добавляет содержимое рабочего каталога в индекс (staging area) для последующего коммита

## Создание коммита

> git add

Команда git commit берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок

-a для добавления всех изменений в индекс без использования git add
-m для передачи сообщения коммита без запуска полноценного редактора

## Просмотр истории коммитов

> git log

Команда git log используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта

## Переключение между веток (коммитов)

> git checkout

Команда git checkout используется для переключения веток и выгрузки их содержимого в рабочий каталог.

При использовании команды git checkout master, мы возвращаемся к основной ветке

## Просмотр разницы между коммитами

> git diff

Команда git diff используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей копией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).

## Просмотр истории изменения коммитов

> git reflog

Команда git reflog просматривает историю изменения голов веток на протяжении вашей работы для поиска коммитов, которые вы могли внезапно потерять, переписывая историю.

## Добавление картинок и игнорирование файлов
Чтобы добавить картинку, надо ввести " ![] () "
Для игнорирования файлов необходимо создать файл ".gitignore", затем добавить его с помощью команды `git add` и указать в файл то, что хотим игнорировать.

## Хочу увидеть конфликт
Пример конфликта:
![Конфликт](conflict.png)

## Создание веток
Чтобы в Git добавить ветку мы используем:
> git branch new_branch

После данной операции ветка уже была создана, но вы по-прежнему находитесь в прежней ветке. Если вы планируете переместиться на другую ветку, в том числе только что созданную, необходимо написать checkout:
> git checkout new_branch

Чаще всего при создании новой ветки git пользователю необходимо сразу же переключиться на нее. В таком случае стоит использовать:
> git checkout branch new_branch

или:
>git checkout -b new_branch

Если пользователю нужно получить список определенного множества веток, то тогда можно воспользоваться ключами. Одними из самых распространенных будут:

> - r — при использовании этого ключа мы получим список удаленных веток,
> - a — используя этот параметр, в выводе будут удаленные и локальные ветки.

## Основы ветвления и слияния веток
>git merge

В Git предусмотрено слияние — перенос изменений с одной ветки на другую. Однако сливаемая ветка (под этим определением мы подразумеваем ветку, у которой берем изменения для «вливания» их в другую ветвь) никак не меняется и остается в прежнем состоянии. Такие преобразования мы получаем, применив git merge
Операция может привести к появлению конфликтов при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния Git останавливает выполнение команды, чтобы вы могли разрешить конфликт.

Также стоит упомянуть о существовании ключей, предназначенных специально для работы с конфликтами:
>—abort — прерывает слияние и возвращает все к началу

>—continue — продолжает слияние после разрешения конфликта

Решить конфликт можно двумя способами:

Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.
Выбрать более подходящий файл, а от второго отказаться.

## Удаление веток
>git branch -d your_branch

Удаление веток не такой простой процесс, как может показаться. Можно случайно удалить несохраненные изменения в исходном коде, что приведет к нежелательным последствиям. Поэтому здесь нужно действовать осторожно. С операцией удаления над ветками справляется уже привычная команда git branch с параметром **-d**

Для корректного удаления нужно помнить несколько правил, чтобы не получить ошибки:

Нельзя удалить ветку, в которой вы находитесь. Git выкинет ошибку и не произведет удаление. Следовательно, нужно перейти на другую ветку.
Git не позволит удалить ветку, у которой есть несохраненные изменения. Так мы избегаем ситуации, когда часть написанного кода будет безвозвратно утеряна. Если же мы уверены, что изменения в этой версии не нужны и их можно смело удалять, то вместо флага **-d** используем **-D**:
> git branch -D your_branch

Соблюдая все условия, нам удастся удалить указанную ветвь.

# Работа с удаленными репозиториями
Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее.
## Просмотри удалённых репозиториев
>git remote


Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду **git remote**. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум **origin** — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование.

Вы можете также указать ключ **-v**, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию

## Добавление удаленных репозиториев
>git remote add

>git clone

Чтобы добавить новый удаленный репозиторий, выполните команду **git remote add** в терминале в каталоге, в котором хранится репозиторий.

Команда git remote add принимает два аргумента:

- имя удаленного репозитория, например, origin;
- URL-адрес удаленного репозитория, например, https://github.com/OWNER/REPOSITORY.git.

Так же репозиторий можно склонировать воспользовавшись команда **git clone** < url >

## Отправка изменений в удалённый репозиторий (Push)
>git push

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: **git push** < remote-name > < branch-name >. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

>$ git push origin master

Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push.

## Получение изменений из удалённого репозитория
>git pull

Если ветка настроена на отслеживание удалённой ветки, то вы можете использовать команду **git pull** чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда **git clone** автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение **git pull**, как правило, извлекает данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

# Pull request

Pull request — это заявка на слияние кода из разных веток. В процессе слияния Git создаст коммит и покажет все изменения в файле кода: добавленные до разветвления строки подсветятся зеленым цветом, удаленные — красным. Так каждый из разработчиков и менеджер проекта увидят, что произошло с кодом после совместной работы над коммитом. Перед окончательным слиянием (merge) все разработчики должны просмотреть изменения кода (code review) и принять их.